# 队列ADT
## 用抽象数据方法进行C语言编程包含以下三个步骤
1. 以抽象、通用的方式描述一个类型，包括其操作；
2. 设计一个函数接口来表示这种新类型；
3. 编写具体代码已实现这个接口。

## 定义队列抽象数据类型
队列（两个特殊属性的列表）：  
*   新的项目只能被添加到列表结尾处；
*   新的项目只能从列表开始处被移植。

队列是一种先进先出（FIFO）的数据形式

## 定义接口
* 创建两个类型名：Item、Queue  ;
* 初始化：将改变一个Queue类型的变量，所以函数应该把一个Queue变量的地址作为参数：  
  void InitializeQueue（Queue *pq）；
* 确定队列为空或满涉及到返回真或假值的函数。函数不改变队列，可以接受一个Queue参数。但是另一方面，如果只传递Queue的地址，可能会更快一些并且可以节省内存，这取决于Queue类型对象的大小。对了表明函数不改变队列，应该使用const限定词：  
  bool QueueIsFull(const Queue * pq);  
  bool QueueIsEmpty(const Queue * pq);
* 指针pq指向一个不能通过pq改变的Queue数据对象。可以为返回队列中项目数的函数定义一个类似的原型：  
  int QueueItemCount(const Queue *pq);
* 向队列尾部添加项目需要表示项目和队列。这种情况下将改变队列，所以必须使用指针。函数可以是void类型，或者可以使用返回值来只是添加项目操作是否成功。  
  bool EnQueue(Item item,Queue *pq);
* 删除项目可以有很多种做法。如果把项目定义为一个结构或者基本类型之一，可以由函数返回项目。函数参数可以是Queue或者指向Queue的指针。  
  Item DeQueue(Queue q);  
  但是下面的原型更通用：  
  bool DeQueue(Item *pitem,Queue *pq);  
  把从队列删除的项目放在有pitem指针指向的位置，并且用返回值只是操作是否成功。
* 清空队列的函数所需的唯一参数是队列的地址，原型为：  
void EmptyTheQueue(Queue *pq);
## 实现接口的数据表示
* 使用哪种C数据形式：  
数组（便于使用，并且向数组中已有数据的末尾添加项目很简单，但是从队列首端删除项目会导致问题）  
* 另一种解决数组实现中删除问题的方法是保持剩下的元素不动，并改变队列首端的位置。（空出的元素变成盲区，队列的可用空间将不断减小）
* 解决盲区问题的另一种方法：使队列成为环形，即将队列的首尾相连。（但是应作一些标记来确保队列尾端没有超出首端）
* 另一种方法是使用链表。优点是删除首项时不需要移动其他项，只需要重置首指针以指向新的首元素。
* 对于队列来说，需要保存首位项的地址，可以通过指针来实现。也可以使用一个计数器来保存队列中的项目个数。

### 向队列中添加项目包括如下步骤：  
1. 创建新节点
2. 把项目复制到新节点
3. 设置节点的next指针为NULL，表明该节点是列表中的最后一个节点
4. 设置当前尾节点的next指针指向新节点，从而将新节点链接到队列中
5. 把rear指针设置为指向新节点，以便找到最后的节点
6. 项目个数加1

### 从队列首端删除项目包括以下步骤：
1. 把项目复制到一个给定的变量中
2. 释放空闲节点使用的内存
3. 重置首指针，使其指向队列的下一项
4. 如果最后一项被删除，把首尾指针均重置为NULL
5. 项目数减1

### 在重要程序中使用一个新的设计（比如队列包）之前，应现对这个新设计进行测试。测试的方法是编写一个短小的程序。这样的程序有时被称为驱动程序(driver)，其唯一的用途时进行测试。